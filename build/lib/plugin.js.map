{"version":3,"sources":["../../src/lib/plugin.js"],"names":["_","require","toKeymap","debug","log","info","error","HOOKS","HOOK_MAP","validatedPlugin","pluginExports","hasHooks","difference","Object","keys","length","TypeError","join","invalidHooks","filter","hook","isUndefined","isFunction","getpluginAPI","bunnyHopOptions","channel","options","connection","serviceName","getChannel","getConnection","getInitialOptions","getServiceName","getPluginLogger","Plugin","pluginAPI","initializedPlugins","runPipeline","hookName","args","hookPipeline","plugin","map","engine","pipeline","fullPipeline","flow","initalizePlugins","plugins","pluginInitializer","send","SEND","publish","PUBLISH","listen","LISTEN","subscribe","SUBSCRIBE","module","exports"],"mappings":"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","file":"plugin.js","sourcesContent":["/**\n * Created by balmasi on 2017-05-31.\n */\nconst _ = require('lodash');\nconst { toKeymap } = require('./util');\nconst debug = require('debug');\n\nconst log = {\n  info: debug('bunnyhop:info:plugin'),\n  error: debug('bunnyhop:error:plugin'),\n  debug: debug('bunnyhop:debug:plugin')\n};\nconst HOOKS = ['send', 'listen', 'publish', 'subscribe'];\nconst HOOK_MAP = toKeymap(HOOKS);\n\nfunction validatedPlugin (pluginExports = {})  {\n  // Does the middleware have at least one of the hooks defined?\n  const hasHooks = _.difference(HOOKS, Object.keys(pluginExports)).length < HOOKS.length;\n  if (!hasHooks) {\n    throw new TypeError(`BunnyHop middleware must have at least one hook defined. Valid hooks are ${HOOKS.join(', ')}`);\n  }\n  const invalidHooks = HOOKS\n    .filter(hook => !(_.isUndefined(pluginExports[hook]) || _.isFunction(pluginExports[hook])));\n  if (invalidHooks.length) {\n    throw new TypeError(`Invalid hooks ${invalidHooks.join(', ')} for middleware. Hooks be either a undefined, or a function. Valid hooks are ${HOOKS.join(', ')}`);\n  }\n\n  return pluginExports;\n}\n\n\nfunction getpluginAPI (bunnyHopOptions) {\n  const { channel, options, connection, serviceName } = bunnyHopOptions;\n  return {\n    getChannel () { return channel; },\n    getConnection () { return connection },\n    getInitialOptions () { return options; },\n    getServiceName () { return serviceName },\n    getPluginLogger () { return log; }\n  };\n}\n\n/**\n *\n * @param {{ channel, connection, initialOptions, serviceName }} bunnyHopOptions\n * @return {object} Plugin interface\n */\nfunction Plugin (bunnyHopOptions) {\n  const pluginAPI = getpluginAPI(bunnyHopOptions);\n  let initializedPlugins;\n\n  function runPipeline (hookName, ...args) {\n    const hookPipeline = initializedPlugins\n      // Only keep the plugins that have the hook we're interested in\n      .filter(plugin => _.isFunction(plugin[hookName]))\n      // get the hook function from the plugin\n      .map(plugin => plugin[hookName]);\n\n    const [ engine, ...pipeline]= hookPipeline;\n    const fullPipeline = _.flow(pipeline)(engine);\n    return fullPipeline(...args);\n  }\n\n\n  return {\n    initalizePlugins: (plugins = []) => {\n      // Provide the bunny hop options for plugins to initialize themselves and return hooks\n      initializedPlugins = plugins.map(pluginInitializer => {\n        return validatedPlugin(\n          pluginInitializer(pluginAPI)\n        );\n      });\n    },\n    send: (...args) => runPipeline(HOOK_MAP.SEND, ...args),\n    publish: ( ...args) => runPipeline(HOOK_MAP.PUBLISH, ...args),\n    listen: (...args) => runPipeline(HOOK_MAP.LISTEN, ...args),\n    subscribe: (...args) => runPipeline(HOOK_MAP.SUBSCRIBE, ...args)\n  }\n}\n\n\nmodule.exports = Plugin;"]}
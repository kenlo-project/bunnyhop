{"version":3,"sources":["../../src/lib/util.js"],"names":["snakeCase","isFunction","require","toKeymap","array","reduce","acc","key","Object","assign","toUpperCase","wrapCompletedHandlers","orignalFn","onError","onSuccess","args","callOnSuccess","returnValue","callOnError","error","returnVal","err","then","catch","module","exports"],"mappings":";;AAAA;;;AAGA,MAAM,EAAEA,SAAF,EAAaC,UAAb,KAA4BC,QAAQ,QAAR,CAAlC;;AAGA;;;;;;;;;;AAUA,SAASC,QAAT,CAAmBC,QAAQ,EAA3B,EAA+B;AAC7B,SAAOA,MAAMC,MAAN,CAAa,CAACC,MAAM,EAAP,EAAWC,GAAX,KAChBC,OAAOC,MAAP,CAAc,EAAE,CAACT,UAAUO,GAAV,EAAeG,WAAf,EAAD,GAAgCH,GAAlC,EAAd,EAAuDD,GAAvD,CADG,EAEL,EAFK,CAAP;AAGD;;AAED;;;;;;;AAOA,MAAMK,wBAAwB,CAACC,SAAD,EAAYC,OAAZ,EAAqBC,SAArB,KAAmC,CAAC,GAAGC,IAAJ,KAAa;AAC5E,QAAMC,gBAAiBC,WAAD,IAAiB;AACrC,QAAIhB,WAAWa,SAAX,CAAJ,EAA2B;AACzBA,gBAAUG,WAAV,EAAuB,GAAGF,IAA1B;AACD;AACD,WAAOE,WAAP;AACD,GALD;AAMA,QAAMC,cAAeC,KAAD,IAAW;AAC7B,QAAIlB,WAAWY,OAAX,CAAJ,EAAyB;AACvBA,cAAQM,KAAR;AACD,KAFD,MAEO;AACL,YAAMA,KAAN;AACD;AACF,GAND;;AAQA,MAAIC,SAAJ;AACA;AACA,MAAI;AACFA,gBAAYR,UAAU,GAAGG,IAAb,CAAZ;AACD,GAFD,CAEE,OAAOM,GAAP,EAAY;AACZ;AACAH,gBAAYG,GAAZ;AACD;;AAED;AACA,MAAID,aAAanB,WAAWmB,UAAUE,IAArB,CAAjB,EAA6C;AAC3C;AACA;AACA,WAAOF,UAAUE,IAAV,CAAeN,aAAf,EAA8BO,KAA9B,CAAoCL,WAApC,CAAP;AACD;;AAED;AACAF,gBAAcI,SAAd;AACA,SAAOA,SAAP;AACD,CAlCD;;AAoCAI,OAAOC,OAAP,GAAiB;AACftB,UADe;AAEfQ;AAFe,CAAjB","file":"util.js","sourcesContent":["/**\n * Created by balmasi on 2017-05-31.\n */\nconst { snakeCase, isFunction } = require('lodash');\n\n\n/**\n * Converts arrays to keymaps\n *\n * @param array\n * @return {object}\n * @example\n * toKeymap(['sendCmd', 'be--Well'])\n * // returns { SEND_CMD: 'sendCmd', BE_WELL: 'be--Well' }\n *\n */\nfunction toKeymap (array = []) {\n  return array.reduce((acc = {}, key) =>\n      Object.assign({ [snakeCase(key).toUpperCase()]: key }, acc)\n  , {});\n}\n\n/**\n * Wraps an onSuccess and onError handler around a function\n * @param {function} orignalFn\n * @param {function} [onError]\n * @param {function} [onSuccess]\n * @return {*} - returns whatever the original function would have returned\n */\nconst wrapCompletedHandlers = (orignalFn, onError, onSuccess) => (...args) => {\n  const callOnSuccess = (returnValue) => {\n    if (isFunction(onSuccess)) {\n      onSuccess(returnValue, ...args);\n    }\n    return returnValue;\n  };\n  const callOnError = (error) => {\n    if (isFunction(onError)) {\n      onError(error);\n    } else {\n      throw error;\n    }\n  };\n\n  let returnVal;\n  // Catch synchronous errors\n  try {\n    returnVal = orignalFn(...args);\n  } catch (err) {\n    // Call error handler on synchronous errors too\n    callOnError(err);\n  }\n\n  // Is returned value Promise-like?\n  if (returnVal && isFunction(returnVal.then)) {\n    // Run success handler side effects\n    // Make sure to capture and consume the error message on returned value\n    return returnVal.then(callOnSuccess).catch(callOnError);\n  }\n\n  // Must be Synchronous - Just call synchronous success handler\n  callOnSuccess(returnVal);\n  return returnVal\n};\n\nmodule.exports = {\n  toKeymap,\n  wrapCompletedHandlers\n};"]}
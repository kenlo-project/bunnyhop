{"version":3,"sources":["../../../src/lib/engines/default.engine.js"],"names":["_","require","debug","uuid","EventEmitter","EXCHANGE_TYPE","log","info","error","DefaultEngine","pluginAPI","ch","getChannel","initialOptions","getInitialOptions","serviceName","getServiceName","defaults","topicExchange","directExchange","rpcReplyQueue","errorFormatter","err","pickedError","pick","assign","stack","split","engineOptions","merge","clone","deserialize","serialize","serialization","DIRECT","assertExchange","TOPIC","rpcResponseEmitter","setMaxListeners","assertQueue","exclusive","then","consume","msg","emit","properties","correlationId","content","noAck","send","routingKey","message","options","msgBuffer","Buffer","JSON","stringify","commonOptions","appId","persistent","headers","Boolean","sync","sendWithOptions","opt","publish","Promise","resolve","reject","uid","v4","handleResponsePromise","msgContent","result","isUndefined","once","replyTo","listen","listenFn","reqMsg","isRpc","get","listenOptions","autoAck","ack","listenerReturn","response","sendToQueue","getResponse","test","TypeError","qName","durable","bindQueue","prefetch","publishOptions","subscribe","subscribeOptions","transformMessage","ConnectionManager","module","exports"],"mappings":"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","file":"default.engine.js","sourcesContent":["/**\n * Created by balmasi on 2017-06-02.\n */\nconst _ = require('lodash');\nconst debug = require('debug');\nconst uuid = require('uuid');\nconst { EventEmitter } = require('events');\n\nconst { EXCHANGE_TYPE } = require('../amqp');\n\nconst log = {\n  info: debug('bunnyhop:info:engine'),\n  error: debug('bunnyhop:error:engine'),\n  debug: debug('bunnyhop:debug:engine')\n};\n\nfunction DefaultEngine (pluginAPI) {\n  const ch = pluginAPI.getChannel();\n  const initialOptions = pluginAPI.getInitialOptions();\n  const serviceName = pluginAPI.getServiceName();\n\n  const defaults = {\n    topicExchange: 'amq.topic',\n    directExchange: 'amq.direct',\n    rpcReplyQueue: `${serviceName}_rpc_replies_${uuid()}`,\n    errorFormatter: err => {\n      const pickedError = _.pick(err, ['name', 'message', 'name', 'stack']);\n      return _.assign(\n        pickedError,\n        { stack: pickedError.stack && pickedError.stack.split('\\n') }\n      );\n    }\n  };\n\n  const engineOptions = _.merge(\n    _.clone(defaults),\n    initialOptions\n  );\n\n  const { deserialize, serialize } = engineOptions.serialization;\n\n  const {\n    directExchange,\n    topicExchange,\n    rpcReplyQueue\n  } = engineOptions;\n\n  log.debug(`Asserting ${EXCHANGE_TYPE.DIRECT} exchange \"${directExchange}\"`);\n  ch.assertExchange(directExchange, EXCHANGE_TYPE.DIRECT);\n  log.debug(`Asserting ${EXCHANGE_TYPE.TOPIC} exchange \"${topicExchange}\"`);\n  ch.assertExchange(topicExchange, EXCHANGE_TYPE.TOPIC);\n\n  ch.rpcResponseEmitter = new EventEmitter();\n  ch.rpcResponseEmitter.setMaxListeners(0);\n\n  // Generate a unique queue for this sender\n  log.debug(`Asserting exclusive queue \"${rpcReplyQueue}\" for RPC call responses.`);\n  ch.assertQueue(rpcReplyQueue, { exclusive: true })\n    .then(() =>\n      ch.consume(rpcReplyQueue,\n        msg => {\n        ch.rpcResponseEmitter.emit(\n          msg.properties.correlationId,\n          msg.content\n        )\n      }\n      ,{ noAck: true }\n    ));\n\n  return {\n    send:\n      async (routingKey, message, options = {}) => {\n        const msgBuffer = new Buffer(JSON.stringify(message));\n\n        // Generate custom publish options here (like custom headers)\n        const commonOptions = _.merge(\n          { appId: serviceName },\n          options,\n          {\n            persistent: true,\n            headers: {\n              'x-isRpc': Boolean(options.sync)\n            }\n          }\n        );\n\n        const sendWithOptions = (opt = {}) => ch.publish(directExchange, routingKey, msgBuffer, _.merge(commonOptions, opt));\n\n        // Response Listen queue\n        if (options.sync) {\n          return new Promise(async (resolve, reject) => {\n            const uid = options.correlationId || uuid.v4();\n            const handleResponsePromise = (msgContent) => {\n              const { result, error } = deserialize(msgContent);\n              return !_.isUndefined(error) ? reject(error) : resolve(result);\n            };\n            // listen for the content emitted on the correlationId event\n            ch.rpcResponseEmitter.once(uid, handleResponsePromise);\n            sendWithOptions({\n              replyTo: rpcReplyQueue,\n              correlationId: uid\n            });\n          });\n        }\n\n        sendWithOptions();\n      },\n\n    listen:\n      async (routingKey, listenFn, options = {}) => {\n        if ((/[*#]/g).test(routingKey)) {\n          throw new TypeError('Routing key cannot contain * or # for \"listen\".');\n        }\n        const listenOptions = _.merge(\n          { appId: serviceName, autoAck: true },\n          options,\n          { noAck: false }\n        );\n        // This creates a queue per every listen pattern\n        const qName = routingKey;\n        log.debug(`Asserting durable queue \"${qName}\"`);\n        await ch.assertQueue(qName, { durable: true });\n        log.debug(`Binding queue \"${qName}\" to exchange \"${directExchange}\" with ${routingKey}`);\n        await ch.bindQueue(qName, directExchange, routingKey);\n        await ch.prefetch(1);\n\n        async function getResponse(reqMsg) {\n          let result;\n          let error;\n          const isRpc = _.get(reqMsg, 'properties.headers[\"x-isRpc\"]', false);\n\n          if (listenOptions.autoAck) {\n            log.debug('Message Auto-Acknowledged');\n            ch.ack(reqMsg);\n          } else  {\n            reqMsg.ack  = () => {\n              log.debug('Message acknowledged.');\n              ch.ack(reqMsg);\n            };\n\n            reqMsg.reject  = () => {\n              log.debug('Message rejected.');\n              ch.reject(reqMsg);\n            };\n          }\n\n          reqMsg.content = deserialize(reqMsg.content);\n\n          const listenerReturn = listenFn(reqMsg);\n          if (isRpc) {\n            try {\n              result = await listenerReturn;\n            } catch (err) {\n              error = engineOptions.errorFormatter(err);\n            }\n\n            const response = { result, error };\n            const { replyTo, correlationId } = reqMsg.properties;\n            await ch.sendToQueue(\n              replyTo,\n              serialize(response),\n              { correlationId }\n            );\n          }\n        }\n\n        return ch.consume(\n          qName,\n          getResponse,\n          listenOptions\n        );\n      },\n\n    publish:\n      async (routingKey, message, options) => {\n        const publishOptions = _.merge(\n          { appId: serviceName },\n          options,\n          { persistent: true  }\n        );\n\n        const msgBuffer = serialize(message);\n        return ch.publish(topicExchange, routingKey, msgBuffer, publishOptions);\n      },\n\n    subscribe:\n      async (routingKey, listenFn, options) => {\n        const subscribeOptions =  _.merge(\n          { appId: serviceName, autoAck: true },\n          options,\n          { noAck: false }\n        );\n\n        const qName = `${serviceName}.subscription.${routingKey}`;\n        log.debug(`Asserting durable queue \"${qName}\"`);\n        await ch.assertQueue(qName, { durable: true });\n\n        log.debug(`Binding queue \"${qName}\" to routing \"${routingKey}\"`);\n        await ch.bindQueue(qName, topicExchange, routingKey);\n\n        function transformMessage (msg) {\n          if (subscribeOptions.autoAck) {\n            log.debug('Message Auto-Acknowledged');\n            ch.ack(msg);\n          } else  {\n            msg.ack  = () => {\n              log.debug('Message acknowledged.');\n              ch.ack(msg);\n            };\n\n            msg.reject  = () => {\n              log.debug('Message rejected.');\n              ch.reject(msg);\n            };\n          }\n          msg.content = deserialize(msg.content);\n          return listenFn(msg);\n        }\n\n        return ch.consume(\n          qName,\n          transformMessage,\n          subscribeOptions\n        );\n      },\n  };\n}\n\nDefaultEngine.ConnectionManager = require('../connectionManager');\n\nmodule.exports = DefaultEngine;"]}